<!-- ## 从javascript运行机制谈起

总所周知，JavaScript语言的一大特点就是 **单线程**，也就是说，**同一个时间只能做一件事**。

举个例子，当我们执行以下代码：

``` js
1 alert('hello world')
2 console.log(200)
```

浏览器先执行第1行：在页面中弹出 "hello world" , 当用户点击确定之后，才会执行第2行：控制台打印200

为什么JavaScript是单线程？我们知道，javascript可以操作DOM，假设一段代码在某个节点里添加内容，另一段代码删除节点的内容，如果同时执行，页面应该如何展示？所以JavaScript的单线程机制是为了避免DOM渲染的冲突。

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。

我们再来看下面的代码：

``` js
// 任务1 ： 1s后 打印1
setTimeout(()=>{
  console.log(1)
},1000)
// 任务2： 打印2
console.log(2)
```

按照前面的结论，打印顺序应该是 ： 1s 后打印1，然后打印2

但是1s的过程，CPU完全是闲着的，运行效率很低，为了解决这个问题，JavaScript先将等待中的任务（异步任务）放到列队中，先运行后面无需等待的任务（同步任务），直到异步任务有结果了，再执行该任务。

所以我们上面的代码，执行结果顺序应该是： 打印2 => 1s后打印1

我们具体描述一下 JS 实现异步执行的运行机制：

①同步任务，在主线程上，行成执行栈
②异步任务，先放在 异步队列中
③待同步任务执行完毕，轮询执行 异步队列 的任务

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）

## 回调函数

但是实际情况是，我们必须等到异步结果处理之后，在处理相关代码。

所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 -->